<h1 id="вводная-часть">Вводная часть</h1>
<h2 id="цель-работы">Цель работы:</h2>
<p>Освоить на практике применение режима однократного гаммирования на
примере кодирования различных исходных текстов одним ключом.</p>
<h2 id="два-текста-кодируются-одним-ключом-однократное-гаммирование.">1.
Два текста кодируются одним ключом (однократное гаммирование).</h2>
<p>Требуется не зная ключа и не стремясь его определить, прочитать оба
текста. Необходимо разработать приложение, позволяющее шифровать и
дешифровать тексты P1 и P2 в режиме однократного гаммирования.
Приложение должно определить вид шифротекстов C1 и C2 обоих текстов P1 и
P2 при известном ключе ; Необходимо определить и выразить аналитически
способ, при котором злоумышленник может прочитать оба текста, не зная
ключа и не стремясь его определить.</p>
<h2 id="рис.-fig-001.">(<span class="citation"
data-cites="fig-001">[рис. @fig-001]</span>).</h2>
<figure id="fig-001">
<img src="image/1.png" style="width:70.0%" alt="рис.1.1" />
<figcaption aria-hidden="true">рис.1.1</figcaption>
</figure>
<h2 id="section">1</h2>
<p>(<span class="citation" data-cites="fig-001">[рис.
@fig-001]</span>).</p>
<figure id="fig-001">
<img src="image/1.png" style="width:70.0%" alt="рис.1.1" />
<figcaption aria-hidden="true">рис.1.1</figcaption>
</figure>
<h2 id="section-1">2</h2>
<p>(<span class="citation" data-cites="fig-002">[рис.
@fig-002]</span>).</p>
<figure id="fig-002">
<img src="image/2.png" style="width:70.0%" alt="рис.2.1" />
<figcaption aria-hidden="true">рис.2.1</figcaption>
</figure>
<h2 id="section-2">3</h2>
<p>(<span class="citation" data-cites="fig-003">[рис.
@fig-003]</span>).</p>
<figure id="fig-003">
<img src="image/3.png" style="width:70.0%" alt="рис.3.1" />
<figcaption aria-hidden="true">рис.3.1</figcaption>
</figure>
<h2 id="section-3">4</h2>
<p>(<span class="citation" data-cites="fig-004">[рис.
@fig-004]</span>).</p>
<figure id="fig-004">
<img src="image/4.png" style="width:70.0%" alt="рис.4.1" />
<figcaption aria-hidden="true">рис.4.1</figcaption>
</figure>
<h2 id="section-4">5</h2>
<p>(<span class="citation" data-cites="fig-005">[рис.
@fig-005]</span>).</p>
<figure id="fig-005">
<img src="image/5.png" style="width:70.0%" alt="рис.5.1" />
<figcaption aria-hidden="true">рис.5.1</figcaption>
</figure>
<h2 id="def-hex_to_texthex_str">def hex_to_text(hex_str):</h2>
<pre><code>&quot;&quot;&quot;Convert hex string to text&quot;&quot;&quot;
bytes_obj = bytes.fromhex(hex_str)
return bytes_obj.decode(&#39;cp1251&#39;)</code></pre>
<p>def text_to_hex(text): “““Convert text to hex string”“” return
text.encode(‘cp1251’).hex().upper()</p>
<p>def xor_hex(hex1, hex2): “““XOR two hex strings”“” bytes1 =
bytes.fromhex(hex1) bytes2 = bytes.fromhex(hex2) result = bytes(a ^ b
for a, b in zip(bytes1, bytes2)) return result.hex().upper()</p>
<p>def gamma_encrypt(text, key_hex): “““Encrypt text using gamma
cipher”“” text_hex = text_to_hex(text) return xor_hex(text_hex,
key_hex)</p>
<p>def gamma_decrypt(cipher_hex, key_hex): “““Decrypt cipher text using
gamma cipher”“” text_hex = xor_hex(cipher_hex, key_hex) return
hex_to_text(text_hex)</p>
<p>def analyze_known_plaintext(c1_hex, c2_hex, known_p1): “““Analyze
when one plaintext is known”“” # C1 ⊕ C2 = P1 ⊕ P2 c1_xor_c2 =
xor_hex(c1_hex, c2_hex)</p>
<pre><code># P2 = C1 ⊕ C2 ⊕ P1
known_p1_hex = text_to_hex(known_p1)
p2_hex = xor_hex(c1_xor_c2, known_p1_hex)

return hex_to_text(p2_hex)</code></pre>
<p>def brute_force_common_patterns(c1_hex, c2_hex, pattern): “““Brute
force common patterns to find plaintexts”“” c1_xor_c2 = xor_hex(c1_hex,
c2_hex) results = []</p>
<pre><code># Try to find the pattern in the XOR result
pattern_hex = text_to_hex(pattern)
pattern_len = len(pattern_hex) // 2

for i in range(0, len(c1_xor_c2) // 2 - pattern_len + 1):
    segment = c1_xor_c2[i*2:(i+pattern_len)*2]
    possible_p1_hex = xor_hex(segment, pattern_hex)
    possible_p1 = hex_to_text(possible_p1_hex)
    
    if all(32 &lt;= ord(c) &lt;= 126 or ord(c) &gt; 1024 for c in possible_p1):
        possible_p2_hex = xor_hex(segment, possible_p1_hex)
        possible_p2 = hex_to_text(possible_p2_hex)
        
        if all(32 &lt;= ord(c) &lt;= 126 or ord(c) &gt; 1024 for c in possible_p2):
            results.append((i, possible_p1, possible_p2))

return results</code></pre>
<h1 id="основная-программа">Основная программа</h1>
<p>if <strong>name</strong> == “<strong>main</strong>”:
print(“Лабораторная работа №8: Шифрование двух текстов одним ключом”)
print(“=” * 60)</p>
<pre><code># Исходные данные из задания
key_hex = &quot;05107F0E4E37D29410092E2257FFC80BB27054&quot;
p1 = &quot;Навашисхолящийот1204&quot;
p2 = &quot;ВсеверныйфилиалБанка&quot;

print(&quot;Исходные данные:&quot;)
print(f&quot;Ключ: {key_hex}&quot;)
print(f&quot;P1: {p1}&quot;)
print(f&quot;P2: {p2}&quot;)
print()

# Шифрование обоих текстов
c1_hex = gamma_encrypt(p1, key_hex)
c2_hex = gamma_encrypt(p2, key_hex)

print(&quot;Шифротексты:&quot;)
print(f&quot;C1: {c1_hex}&quot;)
print(f&quot;C2: {c2_hex}&quot;)
print()

# Демонстрация свойства: C1 ⊕ C2 = P1 ⊕ P2
c1_xor_c2 = xor_hex(c1_hex, c2_hex)
p1_xor_p2 = xor_hex(text_to_hex(p1), text_to_hex(p2))

print(&quot;Проверка свойства C1 ⊕ C2 = P1 ⊕ P2:&quot;)
print(f&quot;C1 ⊕ C2: {c1_xor_c2}&quot;)
print(f&quot;P1 ⊕ P2: {p1_xor_p2}&quot;)
print(f&quot;Свойство выполняется: {c1_xor_c2 == p1_xor_p2}&quot;)
print()

# Анализ при известном одном из текстов
print(&quot;Анализ при известном P1:&quot;)
recovered_p2 = analyze_known_plaintext(c1_hex, c2_hex, p1)
print(f&quot;Восстановленный P2: {recovered_p2}&quot;)
print(f&quot;P2 корректно восстановлен: {recovered_p2 == p2}&quot;)
print()

# Попытка анализа без знания ключа и текстов
print(&quot;Попытка анализа без знания текстов (с использованием шаблонов):&quot;)
common_patterns = [&quot;Банка&quot;, &quot;филиал&quot;, &quot;Нава&quot;, &quot;1204&quot;]

for pattern in common_patterns:
    print(f&quot;Анализ с шаблоном &#39;{pattern}&#39;:&quot;)
    results = brute_force_common_patterns(c1_hex, c2_hex, pattern)
    
    for pos, found_p1, found_p2 in results:
        print(f&quot;  Позиция {pos}: P1=&#39;{found_p1}&#39;, P2=&#39;{found_p2}&#39;&quot;)
    print()

# Демонстрация уязвимости повторного использования ключа
print(&quot;Уязвимость повторного использования ключа:&quot;)
print(&quot;Зная C1 ⊕ C2 = P1 ⊕ P2, злоумышленник может:&quot;)
print(&quot;1. Угадать часть P1 (шаблон сообщения)&quot;)
print(&quot;2. Вычислить соответствующую часть P2 = C1 ⊕ C2 ⊕ P1&quot;)
print(&quot;3. Использовать найденную часть P2 для угадывания большего фрагмента P1&quot;)
print(&quot;4. Повторять процесс до полного восстановления обоих текстов&quot;)</code></pre>
<h2 id="программа-продемонстрировала">Программа продемонстрировала:</h2>
<p>Шифрование двух текстов одним ключом - получены шифротексты C1 и
C2</p>
<p>Проверку свойства C1 ⊕ C2 = P1 ⊕ P2 - свойство выполняется</p>
<p>Восстановление P2 при известном P1 - текст успешно восстановлен без
знания ключа</p>
<p>Анализ с использованием шаблонов - показана возможность частичного
восстановления текстов</p>
<p>Ответы на контрольные вопросы Как определить другой текст, зная один
из них? По формуле: P2 = C1 ⊕ C2 ⊕ P1 (или P1 = C1 ⊕ C2 ⊕ P2)</p>
<p>Что будет при повторном использовании ключа? Возникает уязвимость:
злоумышленник может восстановить оба текста, зная только шифротексты и
угадав часть одного из сообщений.</p>
<p>Как реализуется режим шифрования? Оба текста шифруются одним ключом:
C1 = P1 ⊕ K, C2 = P2 ⊕ K</p>
<p>Недостатки шифрования одним ключом:</p>
<p>Уязвимость к атакам на повторное использование ключа</p>
<p>Возможность восстановления текстов без знания ключа</p>
<p>Снижение криптостойкости системы</p>
<p>Преимущества шифрования одним ключом:</p>
<p>Экономия на генерации и распределении ключей</p>
<p>Упрощение управления ключами</p>
<p>Повышение эффективности при массовой</p>
<h2 id="выводы">Выводы</h2>
<p>В ходе лабораторной работы была изучена уязвимость повторного
использования ключа при однократном гаммировании. Основные выводы:</p>
<p>Повторное использование ключа критически опасно - позволяет
восстановить оба текста без знания ключа</p>
<p>Свойство C1 ? C2 = P1 ? P2 является основной уязвимостью системы</p>
<p>Даже частичное знание одного текста позволяет восстановить
значительные части другого текста</p>
<p>Итеративный процесс анализа позволяет постепенно восстанавливать оба
сообщения</p>
<p>Абсолютная стойкость однократного гаммирования нарушается при
повторном использовании ключа</p>
<p>Работа наглядно продемонстрировала важность соблюдения основного
принципа криптографии - никогда не использовать ключ более одного раза,
особенно в схемах с теоретически абсолютной стойкостью.</p>
