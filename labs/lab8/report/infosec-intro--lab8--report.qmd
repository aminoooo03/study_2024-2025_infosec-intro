# Лабораторная работа №8


**Выполнила:** Накова Амина Михайловна, НПИбд-02-23

### Цель работы

Освоить на практике применение режима однократного гаммирования на примере кодирования различных исходных текстов одним ключом

### Выполнение работы

#### 1.	Два текста кодируются одним ключом (однократное гаммирование).
Требуется не зная ключа и не стремясь его определить, прочитать оба текста. Необходимо разработать приложение, позволяющее шифровать и дешифровать тексты P1 и P2 в режиме однократного гаммирования. Приложение должно определить вид шифротекстов C1 и C2 обоих текстов P1 и
P2 при известном ключе ; Необходимо определить и выразить аналитически способ, при котором злоумышленник может прочитать оба текста, не
зная ключа и не стремясь его определить.



def hex_to_text(hex_str):
    """Convert hex string to text"""
    bytes_obj = bytes.fromhex(hex_str)
    return bytes_obj.decode('cp1251')

def text_to_hex(text):
    """Convert text to hex string"""
    return text.encode('cp1251').hex().upper()

def xor_hex(hex1, hex2):
    """XOR two hex strings"""
    bytes1 = bytes.fromhex(hex1)
    bytes2 = bytes.fromhex(hex2)
    result = bytes(a ^ b for a, b in zip(bytes1, bytes2))
    return result.hex().upper()

def gamma_encrypt(text, key_hex):
    """Encrypt text using gamma cipher"""
    text_hex = text_to_hex(text)
    return xor_hex(text_hex, key_hex)

def gamma_decrypt(cipher_hex, key_hex):
    """Decrypt cipher text using gamma cipher"""
    text_hex = xor_hex(cipher_hex, key_hex)
    return hex_to_text(text_hex)

def analyze_known_plaintext(c1_hex, c2_hex, known_p1):
    """Analyze when one plaintext is known"""
    # C1 ⊕ C2 = P1 ⊕ P2
    c1_xor_c2 = xor_hex(c1_hex, c2_hex)
    
    # P2 = C1 ⊕ C2 ⊕ P1
    known_p1_hex = text_to_hex(known_p1)
    p2_hex = xor_hex(c1_xor_c2, known_p1_hex)
    
    return hex_to_text(p2_hex)

def brute_force_common_patterns(c1_hex, c2_hex, pattern):
    """Brute force common patterns to find plaintexts"""
    c1_xor_c2 = xor_hex(c1_hex, c2_hex)
    results = []
    
    # Try to find the pattern in the XOR result
    pattern_hex = text_to_hex(pattern)
    pattern_len = len(pattern_hex) // 2
    
    for i in range(0, len(c1_xor_c2) // 2 - pattern_len + 1):
        segment = c1_xor_c2[i*2:(i+pattern_len)*2]
        possible_p1_hex = xor_hex(segment, pattern_hex)
        possible_p1 = hex_to_text(possible_p1_hex)
        
        if all(32 <= ord(c) <= 126 or ord(c) > 1024 for c in possible_p1):
            possible_p2_hex = xor_hex(segment, possible_p1_hex)
            possible_p2 = hex_to_text(possible_p2_hex)
            
            if all(32 <= ord(c) <= 126 or ord(c) > 1024 for c in possible_p2):
                results.append((i, possible_p1, possible_p2))
    
    return results

# Основная программа
if __name__ == "__main__":
    print("Лабораторная работа №8: Шифрование двух текстов одним ключом")
    print("=" * 60)
    
    # Исходные данные из задания
    key_hex = "05107F0E4E37D29410092E2257FFC80BB27054"
    p1 = "Навашисхолящийот1204"
    p2 = "ВсеверныйфилиалБанка"
    
    print("Исходные данные:")
    print(f"Ключ: {key_hex}")
    print(f"P1: {p1}")
    print(f"P2: {p2}")
    print()
    
    # Шифрование обоих текстов
    c1_hex = gamma_encrypt(p1, key_hex)
    c2_hex = gamma_encrypt(p2, key_hex)
    
    print("Шифротексты:")
    print(f"C1: {c1_hex}")
    print(f"C2: {c2_hex}")
    print()
    
    # Демонстрация свойства: C1 ⊕ C2 = P1 ⊕ P2
    c1_xor_c2 = xor_hex(c1_hex, c2_hex)
    p1_xor_p2 = xor_hex(text_to_hex(p1), text_to_hex(p2))
    
    print("Проверка свойства C1 ⊕ C2 = P1 ⊕ P2:")
    print(f"C1 ⊕ C2: {c1_xor_c2}")
    print(f"P1 ⊕ P2: {p1_xor_p2}")
    print(f"Свойство выполняется: {c1_xor_c2 == p1_xor_p2}")
    print()
    
    # Анализ при известном одном из текстов
    print("Анализ при известном P1:")
    recovered_p2 = analyze_known_plaintext(c1_hex, c2_hex, p1)
    print(f"Восстановленный P2: {recovered_p2}")
    print(f"P2 корректно восстановлен: {recovered_p2 == p2}")
    print()
    
    # Попытка анализа без знания ключа и текстов
    print("Попытка анализа без знания текстов (с использованием шаблонов):")
    common_patterns = ["Банка", "филиал", "Нава", "1204"]
    
    for pattern in common_patterns:
        print(f"Анализ с шаблоном '{pattern}':")
        results = brute_force_common_patterns(c1_hex, c2_hex, pattern)
        
        for pos, found_p1, found_p2 in results:
            print(f"  Позиция {pos}: P1='{found_p1}', P2='{found_p2}'")
        print()
    
    # Демонстрация уязвимости повторного использования ключа
    print("Уязвимость повторного использования ключа:")
    print("Зная C1 ⊕ C2 = P1 ⊕ P2, злоумышленник может:")
    print("1. Угадать часть P1 (шаблон сообщения)")
    print("2. Вычислить соответствующую часть P2 = C1 ⊕ C2 ⊕ P1")
    print("3. Использовать найденную часть P2 для угадывания большего фрагмента P1")
    print("4. Повторять процесс до полного восстановления обоих текстов")


([рис. @fig-001]).

![рис.1.1](image/1.png){#fig-001 width=70%}

([рис. @fig-002]).

![рис.2.1](image/2.png){#fig-002 width=70%}

([рис. @fig-003]).

![рис.3.1](image/3.png){#fig-003 width=70%}

([рис. @fig-004]).

![рис.4.1](image/4.png){#fig-004 width=70%}

([рис. @fig-005]).

![рис.5.1](image/5.png){#fig-005 width=70%}

Программа продемонстрировала:

Шифрование двух текстов одним ключом - получены шифротексты C1 и C2

Проверку свойства C1 ⊕ C2 = P1 ⊕ P2 - свойство выполняется

Восстановление P2 при известном P1 - текст успешно восстановлен без знания ключа

Анализ с использованием шаблонов - показана возможность частичного восстановления текстов





























Ответы на контрольные вопросы
Как определить другой текст, зная один из них?
По формуле: P2 = C1 ⊕ C2 ⊕ P1 (или P1 = C1 ⊕ C2 ⊕ P2)

Что будет при повторном использовании ключа?
Возникает уязвимость: злоумышленник может восстановить оба текста, зная только шифротексты и угадав часть одного из сообщений.

Как реализуется режим шифрования?
Оба текста шифруются одним ключом: C1 = P1 ⊕ K, C2 = P2 ⊕ K

Недостатки шифрования одним ключом:

Уязвимость к атакам на повторное использование ключа

Возможность восстановления текстов без знания ключа

Снижение криптостойкости системы

Преимущества шифрования одним ключом:

Экономия на генерации и распределении ключей

Упрощение управления ключами

Повышение эффективности при массовой обработке



#### Выводы:

В ходе лабораторной работы была изучена уязвимость повторного использования ключа при однократном гаммировании. Основные выводы:

Повторное использование ключа критически опасно - позволяет восстановить оба текста без знания ключа

Свойство C1 ⊕ C2 = P1 ⊕ P2 является основной уязвимостью системы

Даже частичное знание одного текста позволяет восстановить значительные части другого текста

Итеративный процесс анализа позволяет постепенно восстанавливать оба сообщения

Абсолютная стойкость однократного гаммирования нарушается при повторном использовании ключа

Работа наглядно продемонстрировала важность соблюдения основного принципа криптографии - никогда не использовать ключ более одного раза, особенно в схемах с теоретически абсолютной стойкостью.

